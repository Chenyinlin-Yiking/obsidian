## 译码器
### 线选法
n 条地址线对应 n 个选片信号，**但是地址空间不连续**

#### 低电平有效
输出时每条输出线加入一个非电路（取反），其中一个目的是为了省电

假设我们希望输入的数据时 101，低电平有效是指把它取反，使得高电压

### 译码片选法
n 条条地址线对应 n 个选片信号，电路复杂但**地址空间连续**
![[主存1.png]]

### 使能端
控制输入译码器的信号稳定后再统一传入译码器，有点类似译码驱动器，只不过后者对象是译码器的输出信号。使能端可能会有多个输入端，比如 138 译码器

### 位扩展
扩展连接后存储单元数量不变，每个单元包含的位由 1 个变为 2 个
对于一个 8k * 1 位的芯片，把它扩展到 8K * 2 位就是所谓的位扩展。对于 8k * 1 位芯片，它有 13 根地址线和 1 根数据线，一共 14 根线。为了能够让 cpu **同时**访问两个芯片，两个芯片的数据线就要**分别连接**cpu 的数据线端口。
![](主存2位扩展.png)

### 字扩展
扩展连接后存储单元包含的位数不变，存储单元的数目增多。
对于一个 8k * 8 位的芯片，由于字扩展**不需要同时**访问两个芯片，只需要确定**应该访问哪个芯片**即可，所以对于原先 13 根地址线肯定是不够的，因此需要**额外加入**地址线用于区分两个芯片。
![地址中最高位（最左边一位）忽略](主存3字扩展.png "地址中最高位（最左边一位）忽略")
<center style = "font-size: 14 px;">地址中最高位（最左边一位）忽略</center>


## 双端口 RAM
它有两套完全独立的数据线，地址线和读写控制线。
但同时也存在问题：两个端口对同一主存的操作有几种情况：
1. 同时对不同地址单元存储数据✔
2. 同时对同一地址单元读出数据✔
3. 同时对同一地址单元写入数据❌
4. 同时对同一地址单元，一个写入数据，一个读出数据❌
解决方案：设置“BUSY”信号，暂时关闭一个端口（被短暂延时），未被关闭的端口正常访问，被关闭的短暂延长后再访问

## 多模块存储器
### 单体多字存储器（类似位扩展）
原先单个存储单元只能存储 w 个字，现在变成 4w 个字，此时总线宽度也是 4w 个字，一次并行读出 4w 个字。
**指令和数据在主存内必须是连续存放的**

### 多体并行存储器
#### 高位交叉编址





 