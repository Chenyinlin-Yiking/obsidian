# Cache
## 局部性
### 时间局部性
最近的访问项（指令/数据）很可能在不久的将来再次被访问（往往会引起对最近使用区域的集中访问），这是因为程序存在循环
### 空间局部性
在最近的未来要用到的信息（指令和数据），很可能于现在正在使用的信息在存储空间上是邻近的，说白了就是下一个访问的信息所在地址相对于当前访问的信息的地址是相邻相接近的。

## 结构
主存为了与 Cache 映像，将主存与 Cache 分成若干块，每块内包含若干个字。对于主存，高 m 位表示主存的块地址——主存块号；低 b 位表示主存块内地址。同理，对于 Cache ，高 c 位是高速缓存块号，低 b 位是 Cache 块内地址，注意块内地址的位数与主存是相同的，但是具体地址以及块号是根据映射算法的不同而不同的。

## 映射机制
### 全相联映射
属于是最无脑的一种方式，写入数据时，只要 Cache 中存在空位就把需要写入的数据块写入；同理，读出数据时，从第一个块开始寻找一直到最后一个。

**好处是 Cache 块利用充分，坏处是读出数据时需要全局搜索，速度慢**

### 直接映射
Cache 块号 = 主存块号 % Cache 块数

**好处：快速得到映射位置，可以很快知道是否命中。坏处是对于特殊的映射情况时存在块利用不充分的情况——比如块数为 8，即将存入的主存块号分别为 0， 8， 16， 24... ，此时按照上面的计算方式不难发现，这一系列主存块号全部映射到 Cache 的 0 号块，其它块没有被利用。**

### 组相联映射
先分组，每组 n 块，总共 Cache 有 m 块，可以得到组数= $m \div n$，映射的时候用主存块号对组数取模，假设当前主存块号 x ，那么映射到 Cache 的组号为 $x \% \frac{m}{n}$，若组内存在多个可存入的块，那随机选择即可。

这个方法结合了前面两者的有点，当组数为 1 组的时候，就是全相联映射，当组数为 Cache 的块数时，就是直接映射。

## 替换策略
### 随机替换策略
从特定的位置随机选组一块换出，速度比其他几种策略快，不考虑局部性原理

### 先进先出 FIFO
选择最早装入 Cache 字块替换出来，实现方便但不能正确反映程序运行的局部性原理，换入换出的时候可能出现**抖动现象——频繁的换入换出的现象（刚被替换的块很快又被调入）**

### 最近最久未使用 LRU（考试经常出现）
选择**最近最久未被使用**块作为调出块，每块设置一个计数器，Cache 每命中一次，命中块计数器清零，其他各块计数器增 1（但不超过最大值）。当需要替换时，将计数值最大的块换出。**四种中唯一符合局部性原理**


### 最不经常使用 LFU
将一段时间内被访问次数最少的那块数据换出，每块设置一个计数器，从 0 开始计数，每访问一次，被访问的块的计数器增 1，当需要替换时，将计数值最小的块换出。

不符合局部性原理。

## 写策略
### 写命中
#### 写回法
当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写入主存。此时在**标记阵列中存在一种标记位——脏位，用于表示块是否被修改过**
#### 全写法/写直通法
当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲。写缓冲是一个队列，当写缓冲队列队满，就会把数据写入主存。该方法问题在于，如果不加写缓冲队列，那么写回主存很慢，虽然能保证数据的同步一致性。

### 写不命中
#### 写分配法
当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache，在 Cache 中修改，**通常搭配写回法使用**。
#### 非写分配法
当 CPU 对 Cache 写不命中时，只写入主存，不调入 Cache，**通常搭配全写法使用**。

**补充：现代计算机通常使用多级 Cache 结构，各级 Cache 间常采用"全写法+非写分配法"，Cache 和主存间常采用“写回法+写分配法”

Q：为什么各级 Cache 间用"全写法+非写分配法"？
A：因为 Cache 之间的访问速度非常快（相对于和主存之间）且各级之间差距不大，因此使用全写法同步写命中时不会因为速度差异过大导致 CPU 需要等待写入完成才能继续下一个指令。

Q： 为什么 Cache 和主存间用“写回法+写分配法”
A： 因为 Cache 和主存的速度差异较大，如果采用全写法，同步时会让 CPU 处于等待数据写入主存（因为写入主存速度很慢），此时采用写回法就可以弥补这一问题。

## 效率计算
### 命中率

$$
命中率 = \frac{Cache 命中次数}{总共访存次数} 
$$
### 平均访存时间
####   先访问 Cache，再访问主存

#### Cache 与主存同时访问

### 效率
$$
Cach|_e = \frac{Cache访问时间}{平均访存时间}
$$



## 整点习题
3. 假设某计算机按字编址，Cache 有 4 个行，Cache 和主存之间交换的块大小为 1 个字。若 Cache 的内容初始为空，采用 2 路组相联映射方式和 LRU 替换策略。访问的主存地址依次为 0，4，8，2，0，6，8，6，4，8 时，命中 Cache 的次数是（）。【全国联考 2012 年】
A.1
B.2
C.3
D.4
考点为 Cache 的映射、替换算法。
计算机按字编址，Cache 和主存之间交换的块大小为 1 个字。说明每 1 个字就是 1 个块。采用 2 路组相联映射方式，就是把 Cache 分为 2 组（路），每块 2 块（行）。题目中的地址（块号）均为偶数，则它们映射到 Cache 的组 0 中的2个块。
0,4 进入 Cache，（0,4）。8,2 进入 Cache，（8,2）。0,6 进入 Cache，（0,6）。8 进入 Cache，（8,6） 访问 6，则命中 1 次，（8，6）。
访问 4，进入 Cache，（4,6）。访问 8，进入 Cache，（4,8）。
可见，总共命中 1 次。所以答案是 A。考研的标准答案认为是 C，请考生斟酌研究。

还是要复习一下 LRU 算法的计数器增加原理，补充一下笔记  

5. 假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写（Write Back）方式，则能存放 4 K 字数据的 Cache 的总容量的位数至少是（）。【全国联考 2015 年】
A.146 K
B.147 K
C.148 K
D.158 K 

考点为考查 Cache 的知识。很多教材只是描述 Cache 块的知识，对每个 Cache 块需要的辅助信息描述不多，会导致计算错误。
每个块是 4 x 4＝16 字节。4 K 字的 Cache 有 4 K x 4÷16＝1 K 个块。4 K 的 Cache 占用的位数是 4 K x 32＝128 K。直接映射时，每个 Cache 块有个 tag 寄存器，记录每个 Cache 块存储的内存块的块号。
主存地址是 32 位，主存地址分为：（tag 号，18 位）（块号，10 位）（块内地址，4 位）。1 K 个 tag 号，占用位数是 18 x 1 K＝18 K。加上每个 Cache 有 1 个 valid 位，总共有 1 K 个 valid 位。加上每个 Cache 有 1 个 modify 位，总共有 1 K 个 modify 位。这样，总共需要位数是 128 K＋20K＝148K。所以选择答案 C。

