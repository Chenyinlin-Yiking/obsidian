## 局部性
### 时间局部性
最近的访问项（指令/数据）很可能在不久的将来再次被访问（往往会引起对最近使用区域的集中访问），这是因为程序存在循环
### 空间局部性
在最近的未来要用到的信息（指令和数据），很可能于现在正在使用的信息在存储空间上是邻近的，说白了就是下一个访问的信息所在地址相对于当前访问的信息的地址是相邻相接近的。

## 结构
主存为了与 Cache 映像，将主存与 Cache 分成若干块，每块内包含若干个字。对于主存，高 m 位表示主存的块地址——主存块号；低 b 位表示主存块内地址。同理，对于 Cache ，高 c 位是高速缓存块号，低 b 位是 Cache 块内地址，注意块内地址的位数与主存是相同的，但是具体地址以及块号是根据映射算法的不同而不同的。

## 映射机制
### 全相联映射
属于是最无脑的一种方式，写入数据时，只要 Cache 中存在空位就把需要写入的数据块写入；同理，读出数据时，从第一个块开始寻找一直到最后一个。

**好处是 Cache 块利用充分，坏处是读出数据时需要全局搜索，速度慢**

### 直接映射
Cache 块号 = 主存块号 % Cache 块数

**好处：快速得到映射位置，可以很快知道是否命中。坏处是对于特殊的映射情况时存在块利用不充分的情况——比如块数为 8，即将存入的主存块号分别为 0， 8， 16， 24... ，此时按照上面的计算方式不难发现，这一系列主存块号全部映射到 Cache 的 0 号块，其它块没有被利用。**

### 组相联映射
先分组，每组 n 块，总共 Cache 有 m 块，可以得到组数= $m \div n$，映射的时候用主存块号对组数取模，假设当前主存块号 x ，那么映射到 Cache 的组号为 $x \% \frac{m}{n}$，若组内存在多个可存入的块，那随机选择即可。

这个方法结合了前面两者的有点，当组数为 1 组的时候，就是全相联映射，当组数为 Cache 的块数时，就是直接映射。

## 替换策略
### 随机替换策略
从特定的位置随机选组一块换出，速度比其他几种策略快，不考虑局部性原理

### 先进先出 FIFO
选择最早装入 Cache 字块替换出来，实现方便但不能正确反映程序运行的局部性原理，换入换出的时候可能出现**抖动现象——频繁的换入换出的现象（刚被替换的块很快又被调入）**

### 最近最久未使用 LRU（考试经常出现）
选择**最近最久未被使用**块作为调出块，每块设置一个计数器，Cache 每命中一次，命中块计数器清零，其他各块计数器增 1（但不超过最大值）。当需要替换时，将计数值最大的块换出。**四种中唯一符合局部性原理**


### 最不经常使用 LFU
将一段时间内被访问次数最少的那块数据换出，每块设置一个计数器，从 0 开始计数，每访问一次，被访问的块的计数器增 1，当需要替换时，将计数值最小的块换出。

不符合局部性原理。

## 写策略




 