# 数据寻址
一地址指令格式一般如下：
<div style="display: flex;">
  <div style="background-color: #007bff; color: white; padding: 10px; flex: 1;">
    <div style="text-align: center;">OP</div>
  </div>
  <div style="background-color: #28a745; color: white; padding: 10px; flex: 1;">
    <div style="text-align: center;">寻址方式 = 看情况</div>
  </div>
  <div style="background-color: #dc3545; color: white; padding: 10px; flex: 1;">
    <div style="text-align: center;">EA = A</div>
  </div>
</div>

## 直接寻址
形式地址 A 就是操作数真实地址，即 EA = A

优点：简单、指令执行阶段仅仅访问一次主存，不需要设计专门计算操作数的地址
缺点：A 的位数限制了寻址的范围，而且操作数的地址不容易更改

联想 C 语言指针，int * p = .... 其中 p 保存的就是数据的地址，所以此处的 A 就是 p，两者一致

## 间接寻址
形式地址存储的并不是操作数的地址，而是操作数地址的地址（一次间接寻址）

对于二次间接寻址，说白了就是操作数地址的地址的地址，如下图：

$A1$ 存储了一个地址，**通过最高位为 1 我们可以知道该地址指向的不是最终操作数而是中间地址，反之最高位为 0 则可知指向的是最终操作数**

$A2$ 同样存储一个地址，但不同于 $A1$，它前面最高位为 0 ，说明它存储的地址指向操作数
![](图片/数据寻址1.png)

优点：可以扩大寻址范围，便于编制程序
缺点：指令在执行阶段要多次访存，多次访存的寻址需根据存储字的最高位确定

## 寄存器寻址
A 直接给出操作数所在的寄存器编号，即 $EA = Ri$，其操作数在由 $Ri$ 所指的寄存器内

优点：指令在执行阶段不访问主存，只访问所在 CPU 内的寄存器，指令字短（可用寄存器数量有限 ）且执行速度块
缺点：寄存器价格昂贵，计算机中寄存器个数有限

## 寄存器间接寻址
寄存器 $Ri$ 中给出的不是一个操作数，而是操作数所在主存单元的地址

优点：比一般的间接寻址快很多
缺点：寄存器价格昂贵，而且在执行阶段需要访存

## 偏移寻址
### 基址寻址

### 

### 